const n='---\nid: 55\nSection: AI & Machine Learning\nslug: articles/interactive-chat-in-promptspark-with-signalr-and-semantic-kernel-chat-completions.html\nname: Interactive Chat in PromptSpark With SignalR\ndescription: Explore how to build a real-time, AI-driven chat application in PromptSpark using ASP.NET SignalR and OpenAI GPT with Semantic Kernel.\nkeywords: "{\\"articleTitle\\":\\"Interactive Chat in PromptSpark With SignalR\\",\\"articleDescription\\":\\"This article explores building a real-time chat application using ASP.NET SignalR and OpenAI\'s GPT models, focusing on agility and efficiency in integration.\\",\\"articleContent\\":\\"# Interactive Chat in PromptSpark With SignalR\\n\\n## Transitioning to a Simplified and Agile Approach\\n\\nThis article reimagines the approach from integrating chat completions into Prompt Spark, focusing on agility and adaptability to meet the needs of a React Native component. By simplifying the integration, the chat completions implementation becomes more efficient and effective, embracing a continuous learning approach. This transition underscores the importance of staying open to better, streamlined methods as new insights emerge, allowing us to build more responsive, user-centric applications.\\n\\n## Building an AI-driven, Real-time Chat\\n\\nThis guide covers the steps to create an interactive chat experience using ASP.NET SignalR for real-time functionality and OpenAI\'s GPT models for intelligent responses, through Semantic Kernel. The goal is to simplify and enhance the process of embedding chat completions, making the design more efficient and ready for a VIT React Native environment.\\n\\n### Introduction\\n\\nIn this article, developers and solution architects will learn how to integrate ASP.NET SignalR with Semantic Kernel\'s chat completion service to build a responsive, intelligent chat application in PromptSpark. SignalR enables real-time communication, while Semantic Kernel leverages OpenAI\'s GPT models for contextually relevant responses.\\n\\n### What You’ll Build and Why It Matters\\n\\nYou’ll create an interactive chat application where users receive immediate, AI-generated responses, closely simulating natural conversation flow. Combining SignalR\'s real-time messaging and Semantic Kernel\'s adaptive AI enhances engagement, suitable for use cases like customer support, virtual assistants, and interactive content.\\n\\n### Setting Up Your Development Environment\\n\\nThis project requires ASP.NET Core, SignalR, and Semantic Kernel. Follow these steps to set up your environment and secure your OpenAI API keys with environment variables.\\n\\n```bash\\ndotnet add package Microsoft.AspNetCore.SignalR\\ndotnet add package Microsoft.SemanticKernel\\n```\\n\\n### Setting Up Program.cs\\n\\nIn this section, we’ll set up the main program configuration in `Program.cs` for the integration of SignalR and OpenAI’s GPT models via Semantic Kernel. This configuration ensures real-time functionality and prepares the AI chat service for prompt responses.\\n\\n#### Logging Configuration\\n\\nAdd console logging for debugging and set a debug level to capture detailed information.\\n\\n```csharp\\nbuilder.Logging.AddConsole();\\nbuilder.Logging.SetMinimumLevel(LogLevel.Debug);\\n```\\n\\n#### SignalR Setup\\n\\nAdd SignalR to the services, enabling real-time messaging capabilities in the application.\\n\\n```csharp\\nbuilder.Services.AddSignalR();\\n```\\n\\n#### OpenAI API Integration\\n\\nConfigure Semantic Kernel’s `AddOpenAIChatCompletion` service, using API keys stored in environment variables. Ensure the environment variables `OPENAI_API_KEY` and `MODEL_ID` are correctly set to avoid errors.\\n\\n```csharp\\nstring apikey = builder.Configuration.GetValue<string>(\\\\"OPENAI_API_KEY\\\\") ?? \\\\"not found\\\\";\\nstring modelId = builder.Configuration.GetValue<string>(\\\\"MODEL_ID\\\\") ?? \\\\"gpt-4o\\\\";\\nbuilder.Services.AddOpenAIChatCompletion(modelId, apikey);\\n```\\n\\n#### Routing and Middleware\\n\\nMap routes for API controllers and the SignalR `ChatHub`, enabling endpoint access and serving static files like the front-end HTML.\\n\\n```csharp\\nvar app = builder.Build();\\napp.UseDefaultFiles();  // Looks for index.html, index.htm by default\\napp.UseStaticFiles();\\n\\napp.MapControllers();\\napp.MapHub<ChatHub>(\\\\"/chatHub\\\\");\\n```\\n\\n### Implementing the SignalR Chat Hub\\n\\nThe ChatHub manages messages, maintains conversation history, and processes real-time user interactions. Below is the implementation of the `ChatHub` class, which initializes with an instance of `IChatCompletionService` and manages message flow with a `ConcurrentDictionary` for chat history.\\n\\n```csharp\\npublic class ChatHub(IChatCompletionService _chatCompletionService) : Hub\\n{\\n  public class ChatEntry\\n  {\\n    public DateTime Timestamp { get; set; }\\n    public string User { get; set; }\\n    public string UserMessage { get; set; }\\n    public string BotResponse { get; set; }\\n  }\\n\\n  private static readonly ConcurrentDictionary<string, List<ChatEntry>> ChatHistoryCache = new();\\n\\n  public async Task SendMessage(string user, string message, string conversationId)\\n  {\\n    if (!ChatHistoryCache.ContainsKey(conversationId))\\n    {\\n      ChatHistoryCache[conversationId] = new List<ChatEntry>();\\n    }\\n    var timestamp = DateTime.Now;\\n\\n    // Broadcast user\'s message\\n    await Clients.All.SendAsync(\\\\"ReceiveMessage\\\\", user, message, conversationId);\\n\\n    var chatHistory = new ChatHistory();\\n    chatHistory.AddSystemMessage(\\\\"You are in a conversation, keep your answers brief, always ask follow-up questions, ask if ready for full answer.\\\\");\\n\\n    foreach (var chatEntry in ChatHistoryCache[conversationId])\\n    {\\n      chatHistory.AddUserMessage(chatEntry.UserMessage);\\n      chatHistory.AddSystemMessage(chatEntry.BotResponse);\\n    }\\n    chatHistory.AddUserMessage(message);\\n\\n    // Generate bot response with streaming\\n    var botResponse = await GenerateStreamingBotResponse(chatHistory, conversationId);\\n\\n    // Add the message to the in-memory cache\\n    ChatHistoryCache[conversationId].Add(new ChatEntry\\n    {\\n      Timestamp = timestamp,\\n      User = user,\\n      UserMessage = message,\\n      BotResponse = botResponse\\n    });\\n  }\\n\\n  private async Task<string> GenerateStreamingBotResponse(ChatHistory chatHistory, string conversationId)\\n  {\\n    var buffer = new StringBuilder();\\n    var message = new StringBuilder();\\n    try\\n    {\\n      await foreach (var response in _chatCompletionService.GetStreamingChatMessageContentsAsync(chatHistory))\\n      {\\n        if (response?.Content != null)\\n        {\\n          buffer.Append(response.Content);\\n\\n          if (response.Content.Contains(\'\\\\n\'))\\n          {\\n            var contentToSend = buffer.ToString();\\n            await Clients.All.SendAsync(\\\\"ReceiveMessage\\\\", \\\\"ChatBot\\\\", contentToSend, conversationId);\\n            await AppendToCsvLog(conversationId, \\\\"System\\\\", contentToSend);\\n            message.Append(contentToSend);\\n            buffer.Clear();\\n          }\\n        }\\n      }\\n\\n      if (buffer.Length > 0)\\n      {\\n        var remainingContent = buffer.ToString();\\n        await Clients.All.SendAsync(\\\\"ReceiveMessage\\\\", \\\\"ChatBot\\\\", remainingContent, conversationId);\\n        message.Append(remainingContent);\\n        await AppendToCsvLog(conversationId, \\\\"System\\\\", remainingContent);\\n      }\\n    }\\n    catch (Exception ex)\\n    {\\n      Console.WriteLine($\\\\"Error in generating bot response: {ex.Message}\\\\");\\n      message.Append(\\\\"An error occurred while processing your request.\\\\");\\n      await Clients.Caller.SendAsync(\\\\"ReceiveMessage\\\\", \\\\"System\\\\", \\\\"An error occurred while processing your request.\\\\");\\n    }\\n    return message.ToString();\\n  }\\n\\n  private async Task AppendToCsvLog(string conversationId, string sender, string message)\\n  {\\n    Console.WriteLine($\\\\"{DateTime.Now}, {conversationId}, {sender}: {message}\\\\");\\n  }\\n}\\n```\\n\\n### Generating AI-Powered Responses with Semantic Kernel\\n\\nThe `GenerateStreamingBotResponse` method in the ChatHub class generates responses asynchronously. This method streams responses to the client in real-time, providing a continuous \\\\"typing\\\\" effect for a more dynamic chat experience.\\n\\n### Building the Front-End for PromptSpark Chat\\n\\nSet up a user-friendly interface with an input box, chat history window, and “send” button. Establish a SignalR connection for real-time messaging, and use streaming for a “typing” effect in AI responses.\\n\\n```javascript\\nconst connection = new signalR.HubConnectionBuilder()\\n  .withUrl(\\\\"/chathub\\\\")\\n  .build();\\n\\nconnection.on(\\\\"ReceiveMessage\\\\", (user, message, conversationId) => {\\n  // Display received messages\\n});\\n```\\n\\n### Front-End Testing with index.html\\n\\nCreate a simple test harness \'index.html\' in the wwwroot folder for the interactive chat interface. It provides a basic layout with Bootstrap styling, enabling users to send messages and view responses in real-time.\\n\\n```html\\n<div class=\\\\"card\\\\">\\n  <div class=\\\\"card-header text-center\\\\">\\n    <h2>PromptSpark Chat</h2>\\n  </div>\\n  <div class=\\\\"card-body\\\\">\\n    <div id=\\\\"userForm\\\\" class=\\\\"mb-4\\\\">\\n      <label for=\\\\"userInput\\\\" class=\\\\"form-label\\\\">Enter your name to join the chat:</label>\\n      <input type=\\\\"text\\\\" id=\\\\"userInput\\\\" class=\\\\"form-control\\\\" placeholder=\\\\"Your name\\\\" />\\n      <button class=\\\\"btn btn-primary mt-2\\\\" onclick=\\\\"joinChat()\\\\">Join Chat</button>\\n    </div>\\n    <div id=\\\\"chatWindow\\\\" style=\\\\"display: none;\\\\">\\n      <ul id=\\\\"messagesList\\\\" class=\\\\"list-unstyled mb-3 p-3 border rounded bg-white\\\\" style=\\\\"height: 300px; overflow-y: scroll;\\\\">\\n      </ul>\\n      <div class=\\\\"input-group\\\\">\\n        <input type=\\\\"text\\\\" id=\\\\"messageInput\\\\" class=\\\\"form-control\\\\" placeholder=\\\\"Type your message here...\\\\" />\\n        <button class=\\\\"btn btn-primary\\\\" onclick=\\\\"sendMessage()\\\\">Send</button>\\n      </div>\\n    </div>\\n  </div>\\n</div>\\n```\\n\\nAdd the following JavaScript code to the \'index.html\' file to establish a SignalR connection and handle real-time messaging.\\n\\n```javascript\\nconst connection = new signalR.HubConnectionBuilder()\\n  .withUrl(\\\\"/chatHub\\\\")\\n  .configureLogging(signalR.LogLevel.Information)\\n  .build();\\n\\nlet userName = \\\\"\\\\";\\nlet conversationId = localStorage.getItem(\\\\"conversationId\\\\") || generateConversationId();\\nlet botMessageElement = null;\\nlocalStorage.setItem(\\\\"conversationId\\\\", conversationId);\\n\\nfunction generateConversationId() {\\n  return Math.random().toString(36).substring(2, 15);\\n}\\n\\nasync function start() {\\n  try {\\n    await connection.start();\\n    console.log(\\\\"Connected to SignalR hub!\\\\");\\n  } catch (err) {\\n    console.error(\\\\"Connection failed: \\\\", err);\\n    setTimeout(start, 5000);\\n  }\\n}\\n\\nconnection.on(\\\\"ReceiveMessage\\\\", (user, message) => {\\n  const messagesList = document.getElementById(\\\\"messagesList\\\\");\\n\\n  if (user === \\\\"ChatBot\\\\") {\\n    if (!botMessageElement) {\\n      botMessageElement = document.createElement(\\\\"li\\\\");\\n      botMessageElement.classList.add(\\\\"mb-2\\\\");\\n      botMessageElement.setAttribute(\\\\"data-user\\\\", \\\\"ChatBot\\\\");\\n      botMessageElement.innerHTML = `<strong>${user}:</strong> <span class=\\\\"bot-message-content\\\\"></span>`;\\n      messagesList.appendChild(botMessageElement);\\n    }\\n    botMessageElement.querySelector(\\\\".bot-message-content\\\\").textContent += message + \\\\" \\\\";\\n  } else {\\n    botMessageElement = null;\\n    const li = document.createElement(\\\\"li\\\\");\\n    li.classList.add(\\\\"mb-2\\\\");\\n    li.innerHTML = `<strong>${user}:</strong> ${message}`;\\n    messagesList.appendChild(li);\\n  }\\n  messagesList.scrollTop = messagesList.scrollHeight;\\n});\\n\\nfunction joinChat() {\\n  userName = document.getElementById(\\\\"userInput\\\\").value.trim();\\n  if (userName) {\\n    document.getElementById(\\\\"userForm\\\\").style.display = \\\\"none\\\\";\\n    document.getElementById(\\\\"chatWindow\\\\").style.display = \\\\"block\\\\";\\n    document.getElementById(\\\\"messageInput\\\\").focus();\\n  }\\n}\\n\\nasync function sendMessage() {\\n  const message = document.getElementById(\\\\"messageInput\\\\").value.trim();\\n  if (userName && message) {\\n    try {\\n      await connection.invoke(\\\\"SendMessage\\\\", userName, message, conversationId);\\n      document.getElementById(\\\\"messageInput\\\\").value = \'\';\\n    } catch (err) {\\n      console.error(\\\\"SendMessage failed: \\\\", err);\\n    }\\n  }\\n}\\n\\ndocument.getElementById(\\\\"messageInput\\\\").addEventListener(\\\\"keypress\\\\", function (event) {\\n  if (event.key === \\\\"Enter\\\\") {\\n    event.preventDefault();\\n    sendMessage();\\n  }\\n});\\n\\nstart();\\n```\\n\\n#### SignalR Connection\\n\\nEstablishes a real-time connection with the SignalR hub. This is some simple JavaScript code that connects to the SignalR hub and logs a message to the console when the connection is successful.\\n\\n```javascript\\nconst connection = new signalR.HubConnectionBuilder()\\n  .withUrl(\\\\"/chathub\\\\")\\n  .build();\\n\\nconnection.on(\\\\"ReceiveMessage\\\\", (user, message, conversationId) => {\\n  // Display received messages\\n});\\n```\\n\\n#### User Interaction\\n\\nProvides a join functionality with a unique conversation"\nimg_src: /img/ArgostoliGreeceBeach.jpg\nlastmod: 2024-08-28\npublishedDate: 2024-10-27\nestimatedReadTime: 5\nchangefreq: monthly\nsubtitle: Building a Real-Time AI-Driven Chat Application\nauthor: Mark Hazleton\nsummary: In this guide, we will explore how to implement a real-time, AI-driven chat application using PromptSpark. By leveraging ASP.NET SignalR and OpenAI\'s GPT via Semantic Kernel, you can create a dynamic and interactive chat experience.\nconclusionTitle: Conclusion\nconclusionSummary: By following these steps, you can build a robust, real-time chat application in PromptSpark using ASP.NET SignalR and OpenAI GPT via Semantic Kernel. This integration not only enhances user interaction but also leverages the power of AI to provide intelligent and context-aware responses.\nconclusionKeyHeading: Bottom Line\nconclusionKeyText: Integrating SignalR and GPT in PromptSpark creates a powerful chat application.\nconclusionText: This guide provides a comprehensive approach to building a real-time chat application, enhancing user interaction with AI-driven insights. Start integrating these technologies today to elevate your applications.\nseo:\n  title: Interactive Chat in PromptSpark \n  titleSuffix:  \n  description: Discover how to build a real-time, AI-driven chat application in PromptSpark using ASP.NET SignalR and OpenAI GPT with Semantic Kernel. Enhance user\n  keywords: Mark Hazleton, PromptSpark, SignalR, Semantic Kernel, OpenAI GPT, real-time chat, AI-driven chat\n  canonical: https://markhazleton.com/articles/interactive-chat-in-promptspark-with-signalr-and-semantic-kernel-chat-completions.html\n  robots: index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\nog:\n  title: Interactive Chat in PromptSpark With SignalR\n  description: Discover how to build a real-time, AI-driven chat application in PromptSpark using ASP.NET SignalR and OpenAI GPT with Semantic Kernel. Enhance user\n  type: article\n  image: null\n  imageAlt: Interactive Chat in PromptSpark With SignalR and Semantic Kernel Chat Completions - Mark Hazleton\ntwitter:\n  title: Interactive Chat in PromptSpark\n  description: Discover how to build a real-time, AI-driven chat application in PromptSpark using ASP.NET SignalR and OpenAI GPT with Semantic Kernel. Enhance user\n  image: null\n  imageAlt: Interactive Chat in PromptSpark With SignalR and Semantic Kernel Chat Completions - Mark Hazleton\nyoutubeUrl: null\nyoutubeTitle: null\n---\n\n# Interactive Chat in PromptSpark With SignalR\r\n\r\n## Building a Real-Time AI-Driven Chat Application\r\n\r\nIn this guide, we will explore how to implement a real-time, AI-driven chat application using PromptSpark. By leveraging ASP.NET SignalR and OpenAI\'s GPT via Semantic Kernel, you can create a dynamic and interactive chat experience.\r\n\r\n### What is PromptSpark?\r\n\r\nPromptSpark is a versatile platform that allows developers to create interactive applications with ease. It provides a robust environment for integrating various technologies to enhance user interaction.\r\n\r\n### Why Use SignalR?\r\n\r\nSignalR is an ASP.NET library that enables real-time web functionality. It allows server-side code to push content to connected clients instantly, making it ideal for chat applications where real-time communication is crucial.\r\n\r\n### Leveraging Semantic Kernel and OpenAI GPT\r\n\r\nSemantic Kernel is a framework that facilitates the integration of AI models like OpenAI\'s GPT into applications. By using Semantic Kernel, developers can harness the power of AI to provide intelligent responses and enhance user interaction in chat applications.\r\n\r\n## Step-by-Step Implementation\r\n\r\n### 1. Setting Up Your Environment\r\n\r\n- **Install ASP.NET Core**: Ensure you have the latest version of ASP.NET Core installed.\r\n- **Create a New Project**: Use Visual Studio or your preferred IDE to create a new ASP.NET Core project.\r\n\r\n### 2. Integrating SignalR\r\n\r\n- **Add SignalR to Your Project**: Use NuGet Package Manager to install the SignalR library.\r\n- **Configure SignalR**: Set up SignalR in your `Startup.cs` file to enable real-time communication.\r\n\r\n```csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddSignalR();\r\n}\r\n\r\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n{\r\n    app.UseSignalR(routes =>\r\n    {\r\n        routes.MapHub<ChatHub>("/chatHub");\r\n    });\r\n}\r\n```\r\n\r\n### 3. Implementing the Chat Hub\r\n\r\n- **Create a Chat Hub**: Implement a SignalR hub to handle chat messages.\r\n\r\n```csharp\r\npublic class ChatHub : Hub\r\n{\r\n    public async Task SendMessage(string user, string message)\r\n    {\r\n        await Clients.All.SendAsync("ReceiveMessage", user, message);\r\n    }\r\n}\r\n```\r\n\r\n### 4. Integrating Semantic Kernel and OpenAI GPT\r\n\r\n- **Install Semantic Kernel**: Add the Semantic Kernel package to your project.\r\n- **Configure AI Model**: Set up the OpenAI GPT model within Semantic Kernel to process chat inputs and generate responses.\r\n\r\n### 5. Building the Frontend\r\n\r\n- **Create a Chat Interface**: Use HTML and JavaScript to build a simple chat interface.\r\n- **Connect to SignalR**: Use JavaScript to connect to the SignalR hub and handle incoming messages.\r\n\r\n```html\r\n<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/3.1.18/signalr.min.js"><\/script>\r\n<script>\r\n    const connection = new signalR.HubConnectionBuilder().withUrl("/chatHub").build();\r\n\r\n    connection.on("ReceiveMessage", function (user, message) {\r\n        // Display message in chat\r\n    });\r\n\r\n    connection.start().catch((err) => console.error(err.toString()));\r\n<\/script>\r\n```\r\n\r\n## Conclusion\r\n\r\nBy following these steps, you can build a robust, real-time chat application in PromptSpark using ASP.NET SignalR and OpenAI GPT via Semantic Kernel. This integration not only enhances user interaction but also leverages the power of AI to provide intelligent and context-aware responses.\r\n\r\n## Additional Resources\r\n\r\n- [ASP.NET SignalR Documentation](https://docs.microsoft.com/en-us/aspnet/core/signalr/)\r\n- [OpenAI GPT](https://openai.com/research/gpt-3/)\r\n- [Semantic Kernel](https://github.com/microsoft/semantic-kernel)\r\n';export{n as default};
